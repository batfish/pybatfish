 - `Configuration data questions <#configuration>`_
 - `Configuration hygiene questions <#hygiene>`_
 - `Configuration compatibility questions <#status>`_
 - `Network adjacency questions <#topology>`_
 - `Flow path questions <#traceroute>`_
 - `Flow search questions <#reachability>`_
 - `ACL and firewall analysis questions <#acl>`_
 - `Routing analysis questions <#routing>`_
 - `Specifier resolvers <#specifiers>`_
 - `Initialization information questions <#initialization>`_
 - `Other questions <#other>`_

.. py:module:: pybatfish.question.bfq


.. _configuration:

Configuration data questions
----------------------------

Questions that return the contents of configuration in a structured format.

.. py:class:: bgpPeerConfiguration(*, nodes, properties, question_name)

   Returns configuration settings for BGP peerings.
   
   Reports configuration settings for each configured BGP peering on each node in the network. This question reports peer-specific settings. Settings that are process-wide are reported by the bgpProcessConfiguration question.
   
   
   :param nodes: Include nodes matching this name or regex.
   :type nodes: nodeSpec
   :param properties: Include properties matching this regex.
   :type properties: bgpPeerPropertySpec

   Return table columns:

   #. **Node**

   #. **VRF**

   #. **Local_AS** -- Local AS number.

   #. **Local_IP** -- Local IPv4 address (null for BGP unnumbered peers).

   #. **Local_Interface**

   #. **Remote_AS** -- Remote AS numbers with which this peer may establish a session.

   #. **Remote_IP**

   #. **Route_Reflector_Client** -- Whether this peer is a route reflector client.

   #. **Cluster_ID** -- Cluster ID of this peer (null for peers that are not route reflector clients).

   #. **Peer_Group** -- Name of the BGP peer group to which this peer belongs.

   #. **Import_Policy** -- Names of import policies to be applied to routes received by this peer.

   #. **Export_Policy** -- Names of export policies to be applied to routes exported by this peer.

   #. **Send_Community** -- Whether this peer propagates communities.

   #. **Is_Passive** -- Whether this peer is passive.

.. py:class:: bgpProcessConfiguration(*, nodes, properties, question_name)

   Returns configuration settings of BGP processes.
   
   Reports configuration settings for each BGP process on each node and VRF in the network. This question reports only process-wide settings. Peer-specific settings are reported by the bgpPeerConfiguration question.
   
   
   :param nodes: Include nodes matching this name or regex.
   :type nodes: nodeSpec
   :param properties: Include properties matching this regex.
   :type properties: bgpProcessPropertySpec

   Return table columns:

   #. **Node**

   #. **VRF**

   #. **Router_ID**

   #. **Route_Reflector** -- Whether any BGP peer in this process is configured as a route reflector client.

   #. **Multipath_Match_Mode** -- Which AS paths are considered equivalent (EXACT_PATH, FIRST_AS, PATH_LENGTH) when multipath BGP is enabled.

   #. **Multipath_EBGP** -- Whether multipath routing is enabled for EBGP.

   #. **Multipath_IBGP** -- Whether multipath routing is enabled for IBGP.

   #. **Neighbors** -- All peers configured on this process, identified by peer address (for active and dynamic peers) or peer interface (for BGP unnumbered peers).

   #. **Tie_Breaker** -- Tie breaking mode (ARRIVAL_ORDER, CLUSTER_LIST_LENGTH, ROUTER_ID).

.. py:class:: definedStructures(*, names, nodes, types, question_name)

   Lists the structures defined in the network.
   
   Lists the structures defined in the network, along with the files and line numbers in which they are defined.
   
   
   :param names: Include structures whose name matches this string or regex.
   
       Default value: ``.*``
   :type names: structureName
   :param nodes: Include files used to generate nodes whose name matches this specifier.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param types: Include structures whose vendor-specific type matches this string or regex.
   
       Default value: ``.*``
   :type types: javaRegex

   Return table columns:

   #. **Structure_Type** -- Vendor-specific type of the structure.

   #. **Structure_Name** -- Name of the structure.

   #. **Source_Lines** -- File and line numbers where the structure is defined.

.. py:class:: f5BigipVipConfiguration(*, nodes, question_name)

   Returns VIP configuration of F5 BIG-IP devices.
   
   Lists all the VIP to server IP mappings contained in F5 BIP-IP configurations.
   
   
   :param nodes: Include nodes matching this name or regex.
   :type nodes: nodeSpec

   Return table columns:

   #. **Node**

   #. **VIP_Name** -- Virtual Service Name.

   #. **VIP_Endpoint** -- Virtual Service Endpoint.

   #. **Servers**

   #. **Description**

.. py:class:: interfaceProperties(*, excludeShutInterfaces, interfaces, nodes, properties, question_name)

   Returns configuration settings of interfaces.
   
   Lists interface-level settings of interfaces. Settings for routing protocols, VRFs, and zones etc. that are attached to interfaces are available via other questions.
   
   
   :param excludeShutInterfaces: Exclude interfaces that are shutdown.
   :type excludeShutInterfaces: boolean
   :param interfaces: Include interfaces matching this specifier.
   :type interfaces: interfacesSpec
   :param nodes: Include nodes matching this specifier.
   :type nodes: nodeSpec
   :param properties: Include properties matching this specifier.
   :type properties: interfacePropertySpec

   Return table columns:

   #. **Interface**

   #. **Access_VLAN** -- VLAN number when the switchport mode is access (null otherwise).

   #. **Active** -- Whether the interface is active.

   #. **Allowed_VLANs** -- Allowed VLAN numbers when the switchport mode is trunk.

   #. **All_Prefixes** -- All IPv4 addresses assigned to the interface.

   #. **Auto_State_VLAN** -- For VLAN interfaces, whether the operational status depends on member switchports.

   #. **Bandwidth** -- Nominal bandwidth in bits/sec, used for protocol cost calculations.

   #. **Blacklisted** -- Whether the interface is considered down for maintenance.

   #. **Channel_Group** -- Name of the aggregated interface (e.g., a port channel) to which this interface belongs.

   #. **Channel_Group_Members** -- For aggregated interfaces (e.g., a port channel), names of constituent interfaces.

   #. **Declared_Names** -- Any aliases explicitly defined for this interface.

   #. **Description** -- Configured interface description.

   #. **DHCP_Relay_Addresses** -- IPv4 addresses to which incoming DHCP requests are relayed.

   #. **Encapsulation_VLAN** -- Number for VLAN encapsulation.

   #. **HSRP_Groups** -- HSRP group identifiers.

   #. **HSRP_Version** -- HSRP version that will be used.

   #. **Incoming_Filter_Name** -- Name of the input IPv4 filter.

   #. **MLAG_ID** -- MLAG identifier of the interface.

   #. **MTU** -- Layer3 MTU of the interface.

   #. **Native_VLAN** -- Native VLAN when switchport mode is trunk.

   #. **OSPF_Area_Name** -- OSPF area to which the interface belongs.

   #. **OSPF_Cost** -- OSPF cost if explicitly configured.

   #. **OSPF_Enabled** -- Whether OSPF is enabled.

   #. **OSPF_Passive** -- Whether interface is in OSPF passive mode.

   #. **OSPF_Point_To_Point** -- Whether OSPF should operate as if its on a point-to-point link.

   #. **Outgoing_Filter_Name** -- Name of the output IPv4 filter.

   #. **Primary_Address** -- Primary IPv4 address along with the prefix length.

   #. **Primary_Network** -- Primary IPv4 subnet, in canonical form.

   #. **Proxy_ARP** -- Whether proxy ARP is enabled.

   #. **Rip_Enabled** -- Whether RIP is enabled.

   #. **Rip_Passive** -- Whether interface is in RIP passive mode.

   #. **PBR_Policy_Name** -- Name of policy-based routing (PBR) policy.

   #. **Spanning_Tree_Portfast** -- Whether spanning-tree portfast feature is enabled.

   #. **Speed** -- Link speed in bits/sec.

   #. **Switchport** -- Whether the interface is configured as switchport.

   #. **Switchport_Mode** -- Switchport mode (ACCESS, DOT1Q_TUNNEL, DYNAMIC_AUTO, DYNAMIC_DESIRABLE, FEX_FABRIC, NONE, TAP, TOOL, TRUNK) for switchport interfaces.

   #. **Switchport_Trunk_Encapsulation** -- Encapsulation type (DOT1Q, ISL, NEGOTIATE) for switchport trunk interfaces.

   #. **VRF** -- Name of the VRF to which the interface belongs.

   #. **VRRP_Groups** -- All VRRP groups to which the interface belongs.

   #. **Zone_Name** -- Name of the firewall zone to which the interface belongs.

.. py:class:: ipOwners(*, duplicatesOnly, question_name)

   Returns where IP addresses are attached in the network.
   
   For each device, lists the mapping from IPs to corresponding interface(s) and VRF(s).
   
   
   :param duplicatesOnly: *Required.* Restrict output to only IP addresses that are duplicated (configured on a different node or VRF) in the snapshot.
   
       Default value: ``False``
   :type duplicatesOnly: boolean

   Return table columns:

   #. **Node** -- Node hostname.

   #. **VRF** -- VRF name.

   #. **Interface** -- Interface name.

   #. **IP** -- IP address.

   #. **Mask** -- Network mask length.

   #. **Active** -- Whether the interface is active.

.. py:class:: mlagProperties(*, idRegex, nodes, question_name)

   Returns MLAG configuration.
   
   Lists the configuration settings for each MLAG domain in the network.
   
   
   :param idRegex: Include MLAG IDs matching this java Regex.
   :type idRegex: javaRegex
   :param nodes: Include nodes matching this specifier.
   :type nodes: nodeSpec

   Return table columns:

   #. **Node** -- Node name.

   #. **MLAG_ID** -- MLAG domain ID.

   #. **Peer_Address** -- Peer's IP address.

   #. **Local_Interface** -- Local interface used for MLAG peering.

   #. **Source_Interface** -- Local interface used as source-interface for MLAG peering.

.. py:class:: namedStructures(*, ignoreGenerated, indicatePresence, nodes, structureNames, structureTypes, question_name)

   Returns named structure definitions.
   
   Return structures defined in the configurations, represented in a vendor-independent JSON format.
   
   
   :param ignoreGenerated: Whether to ignore auto-generated structures.
   
       Default value: ``True``
   :type ignoreGenerated: boolean
   :param indicatePresence: Output if the structure is present or absent.
   :type indicatePresence: boolean
   :param nodes: Include nodes matching this specifier.
   :type nodes: nodeSpec
   :param structureNames: Include structures matching this name or regex.
   :type structureNames: structureName
   :param structureTypes: Include structures of this type.
   :type structureTypes: namedStructureSpec

   Return table columns:

   #. **Node**

   #. **Structure_Type** -- Structure type.

   #. **Structure_Name** -- Structure name.

   #. **Structure_Definition** -- Structure definition.

.. py:class:: nodeProperties(*, nodes, properties, question_name)

   Returns configuration settings of nodes.
   
   Lists global settings of devices in the network. Settings that are specific to interfaces, routing protocols, etc. are available via other questions.
   
   
   :param nodes: Include nodes matching this name or regex.
   :type nodes: nodeSpec
   :param properties: Include properties matching this regex.
   :type properties: nodePropertySpec

   Return table columns:

   #. **Node**

   #. **AS_Path_Access_Lists** -- Names of AS path access lists.

   #. **Authentication_Key_Chains** -- Names of authentication keychains.

   #. **Community_Lists** -- Names of community lists.

   #. **Configuration_Format** -- Configuration format of the node.

   #. **Default_Cross_Zone_Action** -- Default action (PERMIT, DENY) for traffic that traverses firewall zones (null for non-firewall nodes).

   #. **Default_Inbound_Action** -- Default action (PERMIT, DENY) for traffic destined for this node.

   #. **Device_Type** -- Device type of this node (HOST, INTERNET, ISP, ROUTER, SWITCH).

   #. **DNS_Servers** -- Configured DNS servers.

   #. **DNS_Source_Interface** -- Source interface to use for communicating with DNS servers.

   #. **Domain_Name** -- Domain name of the node.

   #. **Hostname** -- Hostname of the node.

   #. **IKE_Phase1_Keys** -- Names of IKE Phase 1 keys.

   #. **IKE_Phase1_Policies** -- Names of IKE Phase 1 policies.

   #. **IKE_Phase1_Proposals** -- Names of IKE Phase 1 proposals.

   #. **Interfaces** -- Names of interfaces.

   #. **IP_Access_Lists** -- Names of IPv4 filters (ACLs, firewall rule sets).

   #. **IP6_Access_Lists** -- Names of IPv6 filters (ACLs, firewall rule sets).

   #. **IPsec_Peer_Configs** -- Names of IPSec peers.

   #. **IPsec_Phase2_Policies** -- Names of IPSec Phase 2 policies.

   #. **IPsec_Phase2_Proposals** -- Names of IPSec Phase 2 proposals.

   #. **Logging_Servers** -- Configured logging servers.

   #. **Logging_Source_Interface** -- Source interface for communicating with logging servers.

   #. **NTP_Servers** -- Configured NTP servers.

   #. **NTP_Source_Interface** -- Source interface for communicating with NTP servers.

   #. **PBR_Policies** -- Names of policy-based routing (PBR) policies.

   #. **Route_Filter_Lists** -- Names of structures that filter IPv4 routes (e.g., prefix lists).

   #. **Route6_Filter_Lists** -- Names of structures that filter IPv6 routes (e.g., prefix lists).

   #. **Routing_Policies** -- Names of policies that manipulate routes (e.g., route maps).

   #. **SNMP_Source_Interface** -- Source interface to use for communicating with SNMP servers.

   #. **SNMP_Trap_Servers** -- Configured SNMP trap servers.

   #. **TACACS_Servers** -- Configured TACACS servers.

   #. **TACACS_Source_Interface** -- Source interface to use for communicating with TACACS servers.

   #. **Vendor_Family** -- Vendor family (AWS, CISCO, CISCO_NXOS, CUMULUS, F5_BIGIP, JUNIPER, UNKNOWN).

   #. **VRFs** -- Names of VRFs present on the node.

   #. **Zones** -- Names of firewall zones on the node.

.. py:class:: ospfAreaConfiguration(*, nodes, question_name)

   Returns configuration parameters of OSPF areas.
   
   Returns information about all OSPF areas defined across the network.
   
   
   :param nodes: Include nodes matching this name or regex.
   :type nodes: nodeSpec

   Return table columns:

   #. **Node**

   #. **VRF**

   #. **Process_ID**

   #. **Area** -- Area number.

   #. **Area_Type** -- Area type.

   #. **Active_Interfaces** -- Names of active interfaces.

   #. **Passive_Interfaces** -- Names of passive interfaces.

.. py:class:: ospfInterfaceConfiguration(*, nodes, properties, question_name)

   Returns OSPF configuration of interfaces.
   
   Returns the interface level OSPF configuration details for the interfaces in the network which run OSPF.
   
   
   :param nodes: Include nodes matching this name or regex.
   :type nodes: nodeSpec
   :param properties: Include properties matching this regex.
   :type properties: ospfPropertySpec

   Return table columns:

   #. **Interface**

   #. **VRF** -- VRF name.

   #. **Process_ID**

   #. **OSPF_Area_Name** -- OSPF area to which the interface belongs.

   #. **OSPF_Passive** -- Whether interface is in OSPF passive mode.

   #. **OSPF_Cost** -- OSPF cost if explicitly configured.

   #. **OSPF_Point_To_Point** -- Whether OSPF should operate as if its on a point-to-point link.

.. py:class:: ospfProcessConfiguration(*, nodes, properties, question_name)

   Returns configuration parameters for OSPF routing processes.
   
   Returns the values of important properties for all OSPF processes running across the network.
   
   
   :param nodes: Include nodes matching this name or regex.
   :type nodes: nodeSpec
   :param properties: Include properties matching this regex.
   :type properties: ospfPropertySpec

   Return table columns:

   #. **Node**

   #. **VRF** -- VRF name.

   #. **Process_ID**

   #. **Areas** -- All OSPF areas for this process.

   #. **Reference_Bandwidth** -- Reference bandwidth in bits/sec used to calculate interface OSPF cost.

   #. **Router_ID** -- Router ID of the process.

   #. **Export_Policy_Sources** -- Names of policies that determine which routes are exported into OSPF.

   #. **Area_Border_Router** -- Whether this process is at the area border (with at least one interface in Area 0 and one in another area).

.. py:class:: referencedStructures(*, names, nodes, types, question_name)

   Lists the references in configuration files to vendor-specific structures.
   
   Lists the references in configuration files to vendor-specific structures, along with the line number, the name and the type of the structure referenced, and configuration context in which each reference occurs.
   
   
   :param names: Include structures whose name matches this string or regex.
   
       Default value: ``.*``
   :type names: structureName
   :param nodes: Include files used to generate nodes whose name matches this specifier.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param types: Include structures whose vendor-specific type matches this string or regex.
   
       Default value: ``.*``
   :type types: javaRegex

   Return table columns:

   #. **Structure_Type** -- Type of structure referenced.

   #. **Structure_Name** -- The referenced structure.

   #. **Context** -- Configuration context in which the reference appears.

   #. **Source_Lines** -- Lines where reference appears.

.. py:class:: switchedVlanProperties(*, excludeShutInterfaces, interfaces, nodes, vlans, question_name)

   Returns configuration settings of switched VLANs.
   
   Lists information about implicitly and explicitly configured switched VLANs.
   
   
   :param excludeShutInterfaces: Exclude interfaces that are shutdown.
   :type excludeShutInterfaces: boolean
   :param interfaces: Include interfaces matching this specifier.
   :type interfaces: interfacesSpec
   :param nodes: Include nodes matching this specifier.
   :type nodes: nodeSpec
   :param vlans: Include VLANs in this space.
   :type vlans: integerSpace

   Return table columns:

   #. **Node**

   #. **VLAN_ID**

   #. **Interfaces** -- Switched interfaces carrying traffic for this VLAN.

   #. **VXLAN_VNI** -- VXLAN VNI with which this VLAN is associated.

.. py:class:: viModel(*, question_name)

   Lists configuration attributes of nodes and edges in the network.
   
   Returns a JSON dictionary with all of the configuration parameters and neighbor relations stored in the vendor independent data-model.

.. py:class:: vxlanVniProperties(*, nodes, properties, question_name)

   Returns configuration settings of VXLANs.
   
   Lists VNI-level network segment settings configured for VXLANs.
   
   
   :param nodes: Include nodes matching this specifier.
   :type nodes: nodeSpec
   :param properties: Include properties matching this specifier.
   :type properties: vxlanVniPropertySpec

   Return table columns:

   #. **Node**

   #. **VNI** -- VXLAN Segment ID.

   #. **Local_VTEP_IP** -- IPv4 address of the local VTEP.

   #. **Multicast_Group** -- IPv4 address of the multicast group.

   #. **VLAN** -- VLAN number for the VNI.

   #. **VTEP_Flood_List** -- All IPv4 addresses in the VTEP flood list.

   #. **VXLAN_Port** -- Destination port number for the VXLAN tunnel.

.. _hygiene:

Configuration hygiene questions
-------------------------------

Questions that flag unused and undefined structures in configurations.

.. py:class:: aaaAuthenticationLogin(*, nodes, question_name)

   Returns nodes that do not require authentication on all virtual terminal lines.
   
   Lists all nodes in the network for which there is a virtual terminal line that does not require authentication.
   
   
   :param nodes: *Required.* Examine AAA Authentication on nodes matching this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec

   Return table columns:

   #. **Node**

   #. **Line_Names** -- Names of virtual terminal lines.

.. py:class:: interfaceMtu(*, interfaces, mtuBytes, nodes, comparator, question_name)

   Finds interfaces where the configured MTU matches the specified comparator and mtuBytes.
   
   For example, if comparator is '<' and mtuBytes is 1500, then only interfaces where the configured MTU is less than 1500 bytes will be returned.
   
   
   :param interfaces: *Required.* Evaluate interfaces matching this specifier.
   
       Default value: ``.*``
   :type interfaces: interfacesSpec
   :param mtuBytes: *Required.* The reference MTU in bytes against which to check the configured MTU.
   
       Default value: ``1500``
   :type mtuBytes: integer
   :param nodes: *Required.* Include nodes matching this specifier.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param comparator: Returned devices will satisfy <comparator> <mtuBytes>. Use '<' to find devices that do not have MTU smaller than the specified <mtuBytes> MTU.
   
       Default value: ``<``
   :type comparator: comparator

   Return table columns:

   #. **Interface**

   #. **MTU** -- Layer3 MTU of the interface.

.. py:class:: undefinedReferences(*, nodes, question_name)

   Identifies undefined references in configuration.
   
   Finds configurations that have references to named structures (e.g., ACLs) that are not defined. Such occurrences indicate errors and can have serious consequences in some cases.
   
   
   :param nodes: *Required.* Look for undefined references on nodes matching this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec

   Return table columns:

   #. **File_Name** -- File containing reference.

   #. **Struct_Type** -- Type of struct reference is supposed to be.

   #. **Ref_Name** -- The undefined reference.

   #. **Context** -- Context of undefined reference.

   #. **Lines** -- Lines where reference appears.

.. py:class:: unusedStructures(*, nodes, question_name)

   Returns nodes with structures such as ACLs, routemaps, etc. that are defined but not used.
   
   Return nodes with structures such as ACLs, routes, etc. that are defined but not used. This may represent a bug in the configuration, which may have occurred because a final step in a template or MOP was not completed. Or it could be harmless extra configuration generated from a master template that is not meant to be used on those nodes.
   
   
   :param nodes: *Required.* Look for unused structures on nodes matching this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec

   Return table columns:

   #. **Structure_Type** -- Vendor-specific type of the structure.

   #. **Structure_Name** -- Name of the structure.

   #. **Source_Lines** -- File and line numbers where the structure is defined.

.. _status:

Configuration compatibility questions
-------------------------------------

Questions that show if configuration settings are compatible across devices.

.. py:class:: bgpSessionCompatibility(*, nodes, remoteNodes, status, type, question_name)

   Returns the compatibility of configured BGP sessions.
   
   Checks the settings of each configured BGP peering and reports any issue with those settings locally or incompatiblity with its remote counterparts. Each row represents one configured BGP peering on a node and contains information about the session it is meant to establish. For dynamic peers, there is one row per compatible remote peer. Statuses that indicate an independently misconfigured peerings include NO_LOCAL_AS, NO_REMOTE_AS, NO_LOCAL_IP (for eBGP single-hop peerings), LOCAL_IP_UNKNOWN_STATICALLY (for iBGP or eBGP multi-hop peerings), NO_REMOTE_IP (for point-to-point peerings), and NO_REMOTE_PREFIX (for dynamic peerings). INVALID_LOCAL_IP indicates that the peering's configured local IP does not belong to any active interface on the node; UNKNOWN_REMOTE indicates that the configured remote IP is not present in the network. A locally valid point-to-point peering is deemed HALF_OPEN if it has no compatible remote peers, UNIQUE_MATCH if it has exactly one compatible remote peer, or MULTIPLE_REMOTES if it has multiple compatible remote peers. A locally valid dynamic peering is deemed NO_MATCH_FOUND if it has no compatible remote peers, or DYNAMIC_MATCH if it has at least one compatible remote peer.
   
   
   :param nodes: Include sessions whose first node matches this specifier.
   :type nodes: nodeSpec
   :param remoteNodes: Include sessions whose second node matches this specifier.
   :type remoteNodes: nodeSpec
   :param status: Only include sessions for which status matches this regex.
   :type status: bgpSessionStatus
   :param type: Only include sessions for which type (ibgp, ebgp_singlehop, ebgp_multihop) matches this regex.
   :type type: bgpSessionType

   Return table columns:

   #. **Node** -- The node where this session is configured.

   #. **VRF** -- The VRF in which this session is configured.

   #. **Local_AS** -- The local AS of the session.

   #. **Local_Interface** -- Local interface of the session.

   #. **Local_IP** -- The local IP of the session.

   #. **Remote_AS** -- The remote AS or list of ASes of the session.

   #. **Remote_Node** -- Remote node for this session.

   #. **Remote_Interface** -- Remote interface for this session.

   #. **Remote_IP** -- Remote IP or prefix for this session.

   #. **Session_Type** -- The type of this session.

   #. **Configured_Status** -- Configured status.

.. py:class:: bgpSessionStatus(*, nodes, remoteNodes, status, type, question_name)

   Returns the dynamic status of configured BGP sessions.
   
   Checks whether configured BGP peerings can be established. Each row represents one configured BGP peering and contains information about the session it is configured to establish. For dynamic peerings, one row is shown per compatible remote peer. Possible statuses for each session are NOT_COMPATIBLE, ESTABLISHED, and NOT_ESTABLISHED. NOT_COMPATIBLE sessions are those where one or both peers are misconfigured; the BgpSessionCompatibility question provides further insight into the nature of the configuration error. NOT_ESTABLISHED sessions are those that are configured compatibly but will not come up because peers cannot reach each other (e.g., due to being blocked by an ACL). ESTABLISHED sessions are those that are compatible and are expected to come up.
   
   
   :param nodes: Include sessions whose first node matches this specifier.
   :type nodes: nodeSpec
   :param remoteNodes: Include sessions whose second node matches this specifier.
   :type remoteNodes: nodeSpec
   :param status: Only include sessions for which status matches this regex.
   :type status: bgpSessionStatus
   :param type: Only include sessions for which type (ibgp, ebgp_singlehop, ebgp_multihop) matches this regex.
   :type type: bgpSessionType

   Return table columns:

   #. **Node** -- The node where this session is configured.

   #. **VRF** -- The VRF in which this session is configured.

   #. **Local_AS** -- The local AS of the session.

   #. **Local_Interface** -- Local interface of the session.

   #. **Local_IP** -- The local IP of the session.

   #. **Remote_AS** -- The remote AS or list of ASes of the session.

   #. **Remote_Node** -- Remote node for this session.

   #. **Remote_Interface** -- Remote interface for this session.

   #. **Remote_IP** -- Remote IP or prefix for this session.

   #. **Session_Type** -- The type of this session.

   #. **Established_Status** -- Established status.

.. py:class:: ipsecSessionStatus(*, nodes, remoteNodes, status, question_name)

   Returns the status of configured IPSec sessions.
   
   Shows configuration settings and status for each configured IPSec tunnel in the network. The status is IPSEC_SESSION_ESTABLISHED for tunnels that are expected to be established; it is IKE_PHASE1_FAILED if IKE parameters negotiation failed; it is IKE_PHASE1_KEY_MISMATCH if IKE negotiation was successful but IKE keys do not match; it is IPSEC_PHASE2_FAILED if negotiation of IPsec parameters failed; and it is MISSING_END_POINT if the remote endpoint for a configured IPsec tunnel could not be found in the network.
   
   
   :param nodes: Include sessions whose first node matches this specifier.
   :type nodes: nodeSpec
   :param remoteNodes: Include sessions whose second node matches this specifier.
   :type remoteNodes: nodeSpec
   :param status: Only include IPSec sessions for which status matches this regex.
   :type status: ipsecSessionStatus

   Return table columns:

   #. **Node** -- IPSec initiator.

   #. **Node_Interface** -- Initiator Interface.

   #. **Node_IP** -- Initiator IP.

   #. **Remote_Node** -- IPSec responder.

   #. **Remote_Node_Interface** -- Responder Interface.

   #. **Remote_Node_IP** -- Responder IP.

   #. **Tunnel_Interfaces** -- Tunnel interfaces pair used in peering session.

   #. **Status** -- IPSec session status.

.. py:class:: ospfSessionCompatibility(*, nodes, remoteNodes, question_name)

   Returns compatible OSPF sessions.
   
   Returns compatible OSPF sessions in the network. A session is compatible if the interfaces involved are not shutdown and do run OSPF, are not OSPF passive and are associated with the same OSPF area.
   
   
   :param nodes: Include nodes matching this name or regex.
   :type nodes: nodeSpec
   :param remoteNodes: Include remote nodes matching this name or regex.
   :type remoteNodes: nodeSpec

   Return table columns:

   #. **Interface**

   #. **VRF**

   #. **IP** -- Ip.

   #. **Area**

   #. **Remote_Interface**

   #. **Remote_VRF**

   #. **Remote_IP**

   #. **Remote_Area**

.. _topology:

Network adjacency questions
---------------------------

Questions that show different types of network adjacencies.

.. py:class:: bgpEdges(*, nodes, remoteNodes, question_name)

   Returns BGP adjacencies.
   
   Lists all BGP adjacencies in the network.
   
   
   :param nodes: *Required.* Include adjacencies whose first node matches this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param remoteNodes: *Required.* Include adjacencies whose second node matches this name or regex.
   
       Default value: ``.*``
   :type remoteNodes: nodeSpec

   Return table columns:

   #. **Node** -- Node from which the edge originates.

   #. **IP** -- IP at the side of originator.

   #. **Interface** -- Interface at which the edge originates.

   #. **AS_Number** -- AS Number at the side of originator.

   #. **Remote_Node** -- Node at which the edge terminates.

   #. **Remote_IP** -- IP at the side of the responder.

   #. **Remote_Interface** -- Interface at which the edge terminates.

   #. **Remote_AS_Number** -- AS Number at the side of responder.

.. py:class:: edges(*, edgeType, nodes, remoteNodes, initial, question_name)

   Returns different types of network adjacencies in a snapshot.
   
   Lists network adjacencies of different types (e.g., Layer 3, BGP, OSPF) in the form of edges. This question is deprecated in favor of specific edges question such as bgpEdges and layer3Edges.
   
   
   :param edgeType: *Required.* Types of edges to include. Default is layer3.
       Allowed values:
   
       * bgp
       * eigrp
       * ipsec
       * isis
       * layer1
       * layer3
       * ospf
       * vxlan
   
       Default value: ``layer3``
   :type edgeType: string
   :param nodes: *Required.* Include edges whose first node matches this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param remoteNodes: *Required.* Include edges whose second node matches this name or regex.
   
       Default value: ``.*``
   :type remoteNodes: nodeSpec
   :param initial: *Required.* Use the initial topology (pre-dataplane computation).
   
       Default value: ``False``
   :type initial: boolean

   Return table columns:

   #. **Interface** -- Interface from which the edge originates.

   #. **IPs**

   #. **Remote_Interface** -- Interface at which the edge terminates.

   #. **Remote_IPs**

.. py:class:: eigrpEdges(*, nodes, remoteNodes, question_name)

   Returns EIGRP adjacencies.
   
   Lists all EIGRP adjacencies in the network.
   
   
   :param nodes: *Required.* Include adjacencies whose first node matches this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param remoteNodes: *Required.* Include adjacencies whose second node matches this name or regex.
   
       Default value: ``.*``
   :type remoteNodes: nodeSpec

   Return table columns:

   #. **Interface** -- Interface from which the edge originates.

   #. **Remote_Interface** -- Interface at which the edge terminates.

.. py:class:: ipsecEdges(*, nodes, remoteNodes, question_name)

   Returns IPSec tunnels.
   
   Lists all IPSec tunnels in the network.
   
   
   :param nodes: *Required.* Include tunnels whose first node matches this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param remoteNodes: *Required.* Include tunnels whose second node matches this name or regex.
   
       Default value: ``.*``
   :type remoteNodes: nodeSpec

   Return table columns:

   #. **Source_Interface** -- Source interface used in the IPsec session.

   #. **Tunnel_Interface** -- Tunnel interface (if any) used in the IPsec session.

   #. **Remote_Source_Interface** -- Remote source interface used in the IPsec session.

   #. **Remote_Tunnel_Interface** -- Remote tunnel interface (if any) used in the IPsec session.

.. py:class:: isisEdges(*, nodes, remoteNodes, question_name)

   Returns ISIS adjacencies.
   
   Lists all ISIS adjacencies in the network.
   
   
   :param nodes: *Required.* Include adjacencies whose first node matches this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param remoteNodes: *Required.* Include adjacencies whose second node matches this name or regex.
   
       Default value: ``.*``
   :type remoteNodes: nodeSpec

   Return table columns:

   #. **Interface** -- Interface from which the edge originates.

   #. **Remote_Interface** -- Interface at which the edge terminates.

.. py:class:: layer1Edges(*, nodes, remoteNodes, question_name)

   Returns Layer 1 links.
   
   Lists all Layer 1 links in the network.
   
   
   :param nodes: *Required.* Include links whose first node matches this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param remoteNodes: *Required.* Include links whose second node matches this name or regex.
   
       Default value: ``.*``
   :type remoteNodes: nodeSpec

   Return table columns:

   #. **Interface** -- Interface from which the edge originates.

   #. **Remote_Interface** -- Interface at which the edge terminates.

.. py:class:: layer3Edges(*, nodes, remoteNodes, question_name)

   Returns Layer 3 links.
   
   Lists all Layer 3 edges in the network.
   
   
   :param nodes: *Required.* Include edges whose first node matches this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param remoteNodes: *Required.* Include edges whose second node matches this name or regex.
   
       Default value: ``.*``
   :type remoteNodes: nodeSpec

   Return table columns:

   #. **Interface** -- Interface from which the edge originates.

   #. **IPs**

   #. **Remote_Interface** -- Interface at which the edge terminates.

   #. **Remote_IPs**

.. py:class:: ospfEdges(*, nodes, remoteNodes, question_name)

   Returns OSPF adjacencies.
   
   Lists all OSPF adjacencies in the network.
   
   
   :param nodes: *Required.* Include adjacencies whose first node matches this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param remoteNodes: *Required.* Include edges whose second node matches this name or regex.
   
       Default value: ``.*``
   :type remoteNodes: nodeSpec

   Return table columns:

   #. **Interface** -- Interface from which the edge originates.

   #. **Remote_Interface** -- Interface at which the edge terminates.

.. py:class:: vxlanEdges(*, nodes, remoteNodes, question_name)

   Returns VXLAN edges.
   
   Lists all VXLAN edges in the network.
   
   
   :param nodes: *Required.* Include edges whose first node matches this name or regex.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param remoteNodes: *Required.* Include edges whose second node matches this name or regex.
   
       Default value: ``.*``
   :type remoteNodes: nodeSpec

   Return table columns:

   #. **VNI** -- VNI of the VXLAN tunnel edge.

   #. **Node** -- Node from which the edge originates.

   #. **Remote_Node** -- Node at which the edge terminates.

   #. **VTEP_Address** -- VTEP IP of node from which the edge originates.

   #. **Remote_VTEP_Address** -- VTEP IP of node at which the edge terminates.

   #. **VLAN** -- VLAN associated with VNI on node from which the edge originates.

   #. **Remote_VLAN** -- VLAN associated with VNI on node at which the edge terminates.

   #. **UDP_Port** -- UDP port of the VXLAN tunnel transport.

   #. **Multicast_Group** -- Multicast group of the VXLAN tunnel transport.

.. _traceroute:

Flow path questions
-------------------

Questions that show paths of specified flows in the network.

.. py:class:: bidirectionalTraceroute(*, startLocation, headers, maxTraces, ignoreFilters, question_name)

   Traces the path(s) for the specified flow, along with path(s) for reverse flows.
   
   This question performs a virtual traceroute in the network from a starting node. A destination IP and ingress (source) node must be specified. Other IP headers are given default values if unspecified.
   If the trace succeeds, a traceroute is performed in the reverse direction.
   
   
   :param startLocation: *Required.* Location (node and interface combination) to start tracing from.
   :type startLocation: locationSpec
   :param headers: *Required.* Packet header constraints.
   :type headers: headerConstraint
   :param maxTraces: Limit the number of traces returned.
   :type maxTraces: integer
   :param ignoreFilters: If set, filters/ACLs encountered along the path are ignored.
   :type ignoreFilters: boolean

   Return table columns:

   #. **Forward_Flow** -- The forward flow.

   #. **Forward_Traces** -- The forward traces.

   #. **New_Sessions** -- Sessions initialized by the forward trace.

   #. **Reverse_Flow** -- The reverse flow.

   #. **Reverse_Traces** -- The reverse traces.

.. py:class:: traceroute(*, startLocation, headers, maxTraces, ignoreFilters, question_name)

   Traces the path(s) for the specified flow.
   
   Performs a virtual traceroute in the network from a starting node. A destination IP and ingress (source) node must be specified. Other IP headers are given default values if unspecified.
   Unlike a real traceroute, this traceroute is directional. That is, for it to succeed, the reverse connectivity is not needed. This feature can help debug connectivity issues by decoupling the two directions.
   
   
   :param startLocation: *Required.* Location (node and interface combination) to start tracing from.
   :type startLocation: locationSpec
   :param headers: *Required.* Packet header constraints.
   :type headers: headerConstraint
   :param maxTraces: Limit the number of traces returned.
   :type maxTraces: integer
   :param ignoreFilters: If set, filters/ACLs encountered along the path are ignored.
   :type ignoreFilters: boolean

   Return table columns:

   #. **Flow** -- The flow.

   #. **Traces** -- The traces for this flow.

   #. **TraceCount** -- The total number traces for this flow.

.. _reachability:

Flow search questions
---------------------

Questions that exhaustively search for flows that meet specified constraints.

.. py:class:: bidirectionalReachability(*, headers, pathConstraints, returnFlowType, question_name)

   Searches for successfully delivered flows that can successfully receive a response.
   
   Performs two reachability analyses, first originating from specified sources, then returning back to those sources. After the first (forward) pass, sets up sessions in the network and creates returning flows for each successfully delivered forward flow. The second pass searches for return flows that can be successfully delivered in the presence of the setup sessions.
   
   
   :param headers: *Required.* Packet header constraints.
   :type headers: headerConstraint
   :param pathConstraints: Constraint the path a flow can take (start/end/transit locations).
   :type pathConstraints: pathConstraint
   :param returnFlowType: Specifies the type of return flows to search.
       Allowed values:
   
       * SUCCESS: Flows that are successful
       * FAILURE: Flows that fail
       * MULTIPATH_INCONSISTENT: Flows that succeed or fail depending on the path
   
       Default value: ``SUCCESS``
   :type returnFlowType: string

   Return table columns:

   #. **Forward_Flow** -- The forward flow.

   #. **Forward_Traces** -- The forward traces.

   #. **New_Sessions** -- Sessions initialized by the forward trace.

   #. **Reverse_Flow** -- The reverse flow.

   #. **Reverse_Traces** -- The reverse traces.

.. py:class:: detectLoops(*, maxTraces, question_name)

   Detects forwarding loops.
   
   Searches across all possible flows in the network and returns example flows that will experience forwarding loops.
   
   
   :param maxTraces: Limit the number of traces returned.
   :type maxTraces: integer

   Return table columns:

   #. **Flow** -- The flow.

   #. **Traces** -- The traces for this flow.

   #. **TraceCount** -- The total number traces for this flow.

.. py:class:: differentialReachability(*, actions, headers, ignoreFilters, invertSearch, maxTraces, pathConstraints, question_name)

   Returns flows that are successful in one snapshot but not in another.
   
   Searches across all possible flows in the network, with the specified header and path constraints, and returns example flows that are successful in one snapshot and not the other. This is a differential question and the reference snapshot to compare against must be provided in the call to answer().
   
   
   :param actions: Only return flows for which the disposition is from this set.
   
       Default value: ``success``
   :type actions: dispositionSpec
   :param headers: Packet header constraints.
   :type headers: headerConstraint
   :param ignoreFilters: Do not apply filters/ACLs during analysis.
   
       Default value: ``False``
   :type ignoreFilters: boolean
   :param invertSearch: Search for packet headers outside the specified headerspace, rather than inside the space.
   :type invertSearch: boolean
   :param maxTraces: Limit the number of traces returned.
   :type maxTraces: integer
   :param pathConstraints: Constraint the path a flow can take (start/end/transit locations).
   :type pathConstraints: pathConstraint

   Return table columns:

   #. **Flow** -- The flow.

   #. **Snapshot_Traces** -- The traces in the BASE snapshot.

   #. **Snapshot_TraceCount** -- The total number traces in the BASE snapshot.

   #. **Reference_Traces** -- The traces in the DELTA snapshot.

   #. **Reference_TraceCount** -- The total number traces in the DELTA snapshot.

.. py:class:: loopbackMultipathConsistency(*, maxTraces, question_name)

   Validates multipath consistency between all pairs of loopbacks.
   
   Finds flows between loopbacks that are treated differently (i.e., dropped versus forwarded) by different paths in the presence of multipath routing.
   
   
   :param maxTraces: Limit the number of traces returned.
   :type maxTraces: integer

   Return table columns:

   #. **Flow** -- The flow.

   #. **Traces** -- The traces for this flow.

   #. **TraceCount** -- The total number traces for this flow.

.. py:class:: multipathConsistency(*, headers, maxTraces, pathConstraints, question_name)

   Validates multipath consistency.
   
   Searches across all flows in the network and returns example flows that are treated differently (i.e., dropped versus forwarded) by different paths in the presence of multipath routing.
   
   
   :param headers: Packet header constraints.
   :type headers: headerConstraint
   :param maxTraces: Limit the number of traces returned.
   :type maxTraces: integer
   :param pathConstraints: Constraint the path a flow can take (start/end/transit locations).
   :type pathConstraints: pathConstraint

   Return table columns:

   #. **Flow** -- The flow.

   #. **Traces** -- The traces for this flow.

   #. **TraceCount** -- The total number traces for this flow.

.. py:class:: reachability(*, pathConstraints, headers, actions, maxTraces, invertSearch, ignoreFilters, question_name)

   Finds flows that match the specified path and header space conditions.
   
   Searches across all flows that match the specified conditions and returns examples of such flows. This question can be used to ensure that certain services are globally accessible and parts of the network are perfectly isolated from each other.
   
   
   :param pathConstraints: Constraint the path a flow can take (start/end/transit locations).
   :type pathConstraints: pathConstraint
   :param headers: Packet header constraints.
   :type headers: headerConstraint
   :param actions: Only return flows for which the disposition is from this set.
   
       Default value: ``success``
   :type actions: dispositionSpec
   :param maxTraces: Limit the number of traces returned.
   :type maxTraces: integer
   :param invertSearch: Search for packet headers outside the specified headerspace, rather than inside the space.
   :type invertSearch: boolean
   :param ignoreFilters: Do not apply filters/ACLs during analysis.
   :type ignoreFilters: boolean

   Return table columns:

   #. **Flow** -- The flow.

   #. **Traces** -- The traces for this flow.

   #. **TraceCount** -- The total number traces for this flow.

.. py:class:: subnetMultipathConsistency(*, maxTraces, question_name)

   Validates multipath consistency between all pairs of subnets.
   
   Searches across all flows between subnets that are treated differently (i.e., dropped versus forwarded) by different paths in the network and returns example flows.
   
   
   :param maxTraces: Limit the number of traces returned.
   :type maxTraces: integer

   Return table columns:

   #. **Flow** -- The flow.

   #. **Traces** -- The traces for this flow.

   #. **TraceCount** -- The total number traces for this flow.

.. _acl:

ACL and firewall analysis questions
-----------------------------------

Questions that analyze ACLs and firewall rules.

.. py:class:: compareFilters(*, nodes, filters, ignoreComposites, question_name)

   Compares filters with the same name in the current and reference snapshots. Returns pairs of lines, one from each filter, that match the same flow(s) but treat them differently (i.e. one permits and the other denies the flow).
   
   This question can be used to summarize how a filter has changed over time. In particular, it highlights differences that cause flows to be denied when they used to be permitted, or vice versa. The output is a table that includes pairs of lines, one from each version of the filter, that both match at least one common flow, and have different action (permit or deny). This is a differential question and the reference snapshot to compare against must be provided in the call to answer().
   
   
   :param nodes: Only evaluate filters present on nodes matching this node specifier.
   :type nodes: nodeSpec
   :param filters: Only evaluate filters that match this filter specifier.
   :type filters: filterSpec
   :param ignoreComposites: Whether to ignore filters that are composed of multiple filters defined in the configs.
   
       Default value: ``False``
   :type ignoreComposites: boolean

   Return table columns:

   #. **Node** -- Hostname.

   #. **Filter_Name** -- The filter name.

   #. **Line_Index** -- The index of the line in the current filter.

   #. **Line_Content** -- The current filter line content.

   #. **Line_Action** -- The current filter line action.

   #. **Reference_Line_Index** -- The index of the line in the reference filter.

   #. **Reference_Line_Content** -- The reference filter line content.

.. py:class:: filterLineReachability(*, filters, ignoreComposites, nodes, question_name)

   Returns unreachable lines in filters (ACLs and firewall rules).
   
   Finds all lines in the specified filters that will not match any packet, either because of being shadowed by prior lines or because of its match condition being empty.
   
   
   :param filters: Specifier for filters to test.
   :type filters: filterSpec
   :param ignoreComposites: Whether to ignore filters that are composed of multiple filters defined in the configs.
   
       Default value: ``False``
   :type ignoreComposites: boolean
   :param nodes: Examine filters on nodes matching this specifier.
   :type nodes: nodeSpec

   Return table columns:

   #. **Sources** -- Filter sources.

   #. **Unreachable_Line** -- Filter line that cannot be matched (i.e., unreachable).

   #. **Unreachable_Line_Action** -- Action performed by the unreachable line (e.g., PERMIT or DENY).

   #. **Blocking_Lines** -- Lines that, when combined, cover the unreachable line.

   #. **Different_Action** -- Whether unreachable line has an action different from the blocking line(s).

   #. **Reason** -- The reason a line is unreachable.

   #. **Additional_Info** -- Additional information.

.. py:class:: findMatchingFilterLines(*, nodes, filters, headers, action, ignoreComposites, question_name)

   Returns lines in filters (ACLs and firewall rules) that match any packet within the specified header constraints.
   
   Finds all lines in the specified filters that match any packet within the specified header constraints.
   
   
   :param nodes: Examine filters on nodes matching this specifier.
   :type nodes: nodeSpec
   :param filters: Specifier for filters to check.
   :type filters: filterSpec
   :param headers: Packet header constraints for which to find matching filter lines.
   :type headers: headerConstraint
   :param action: Show filter lines with this action. By default returns lines with either action.
       Allowed values:
   
       * permit: Return only lines that permit packets
       * deny: Return only lines that deny packets
   :type action: string
   :param ignoreComposites: Whether to ignore filters that are composed of multiple filters defined in the configs.
   
       Default value: ``False``
   :type ignoreComposites: boolean

   Return table columns:

   #. **Node**

   #. **Filter** -- Filter name.

   #. **Line** -- Line text.

   #. **Line_Index** -- Index of line.

   #. **Action** -- Action performed by the line (e.g., PERMIT or DENY).

.. py:class:: searchFilters(*, action, explain, filters, headers, invertSearch, nodes, startLocation, question_name)

   Finds flows for which a filter takes a particular behavior.
   
   This question searches for flows for which a filter (access control list) has a particular behavior. The behaviors can be: that the filter permits the flow (permit), that it denies the flow (deny), or that the flow is matched by a particular line (matchLine <lineNumber>). Filters are selected using node and filter specifiers, which might match multiple filters. In this case, a (possibly different) flow will be found for each filter.
   
   
   :param action: The behavior that you want evaluated. Options are: permit|deny|matchLine <line number>. Only one option should be selected.
   :type action: string
   :param explain: Include a description of the flow space matching the query.
   :type explain: boolean
   :param filters: Only evaluate filters that match this specifier.
   :type filters: filterSpec
   :param headers: Packet header constraints on the flows being searched.
   :type headers: headerConstraint
   :param invertSearch: Search for packet headers outside the specified headerspace, rather than inside the space.
   :type invertSearch: boolean
   :param nodes: Only evaluate filters present on nodes matching this specifier.
   :type nodes: nodeSpec
   :param startLocation: Only consider specified locations as possible sources.
   :type startLocation: locationSpec

   Return table columns:

   #. **Node**

   #. **Filter_Name** -- Filter name.

   #. **Flow** -- Evaluated flow.

   #. **Action** -- Outcome.

   #. **Line_Content** -- Line content.

   #. **Trace** -- ACL trace.

.. py:class:: testFilters(*, filters, headers, nodes, startLocation, question_name)

   Returns how a flow is processed by a filter (ACLs, firewall rules).
   
   Shows how the specified flow is processed through the specified filters, returning its permit/deny status as well as the line(s) it matched.
   
   
   :param filters: *Required.* Only consider filters that match this specifier.
   
       Default value: ``.*``
   :type filters: filterSpec
   :param headers: *Required.* Packet header constraints.
   :type headers: headerConstraint
   :param nodes: *Required.* Only examine filters on nodes matching this specifier.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param startLocation: Location to start tracing from.
   :type startLocation: string

   Return table columns:

   #. **Node**

   #. **Filter_Name** -- Filter name.

   #. **Flow** -- Evaluated flow.

   #. **Action** -- Outcome.

   #. **Line_Content** -- Line content.

   #. **Trace** -- ACL trace.

.. _routing:

Routing analysis questions
--------------------------

Questions that analyze routing

.. py:class:: lpmRoutes(*, ip, nodes, vrfs, question_name)

   Returns routes that are longest prefix match for a given IP address.
   
   Return longest prefix match routes for a given IP in the RIBs of specified nodes and VRFs.
   
   
   :param ip: *Required.* IP address to run LPM on.
   :type ip: ip
   :param nodes: *Required.* Examine routes on nodes matching this specifier.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param vrfs: *Required.* Examine routes on VRFs matching this name or regex.
   
       Default value: ``.*``
   :type vrfs: vrf

   Return table columns:

   #. **Node** -- Node where the route is present.

   #. **VRF** -- VRF where the route is present.

   #. **Ip** -- IP that was being matched on.

   #. **Network** -- The longest-prefix network that matched.

   #. **Num_Routes** -- Number of routes that matched (in case of ECMP).

.. py:class:: prefixTracer(*, nodes, prefix, question_name)

   Traces prefix propagation through the network.
   
   Shows how prefixes are treated by devices in the network during routing.
   
   
   :param nodes: Include prefix tracing information for nodes matching this name or regex.
   :type nodes: nodeSpec
   :param prefix: The prefix to trace. Expected format is A.B.C.D/Y.
   :type prefix: prefix

   Return table columns:

   #. **Node** -- The node where action takes place.

   #. **VRF** -- The VRF where action takes place.

   #. **Peer** -- The node's neighbor to which the action applies.

   #. **Action** -- The action that takes place.

   #. **Prefix** -- The prefix in question.

.. py:class:: routes(*, nodes, vrfs, network, protocols, rib, question_name)

   Returns routing tables.
   
   Shows routes for specified RIB, VRF, and node(s).
   
   
   :param nodes: *Required.* Examine routes on nodes matching this specifier.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param vrfs: *Required.* Examine routes on VRFs matching this name or regex.
   
       Default value: ``.*``
   :type vrfs: vrf
   :param network: Examine routes for networks matching this prefix.
   :type network: prefix
   :param protocols: Examine routes for protocols matching this specifier.
   :type protocols: routingProtocolSpec
   :param rib: Only return routes from a given protocol RIB.
       Allowed values:
   
       * main
       * bgp
       * evpn
   :type rib: string

   Return table columns:

   #. **Node**

   #. **VRF** -- VRF name.

   #. **Network** -- Network for this route.

   #. **Next_Hop** -- Inferred hostname of the next hop.

   #. **Next_Hop_IP** -- Route's Next Hop IP.

   #. **Next_Hop_Interface** -- Route's Next Hop Interface.

   #. **Protocol** -- Route's Protocol.

   #. **Metric** -- Route's Metric.

   #. **Admin_Distance** -- Route's Admin distance.

   #. **Tag** -- Tag for this route.

.. py:class:: testRoutePolicies(*, nodes, policies, inputRoutes, direction, question_name)

   Evaluates the processing of a route by a given policy.
   
   Find how the specified route is processed through the specified routing policies.
   
   
   :param nodes: *Required.* Only examine filters on nodes matching this specifier.
   
       Default value: ``.*``
   :type nodes: nodeSpec
   :param policies: *Required.* Only consider policies that match this specifier.
   
       Default value: ``.*``
   :type policies: string
   :param inputRoutes: *Required.* The BGP route announcements to test the policy on.
   :type inputRoutes: bgpRoutes
   :param direction: *Required.* The direction of the route, with respect to the device (IN/OUT).
       Allowed values:
   
       * in: The route is inbound to the device
       * out: The route is outbound from the device
   :type direction: string

.. _specifiers:

Specifier resolvers
-------------------

Questions that resolve specifier expressions.

.. py:class:: resolveFilterSpecifier(*, filters, grammarVersion, nodes, question_name)

   Returns the set of filters corresponding to a filterSpec value.
   
   Helper question that shows how specified filterSpec values resolve to the filters in the network.
   
   
   :param filters: *Required.* Input to the FilterSpecifier.
   :type filters: filterSpec
   :param grammarVersion: Version of grammar to use for resolution.
   :type grammarVersion: string
   :param nodes: Input to the NodeSpecifier that specifies the set of nodes that should be considered.
   
       Default value: ``/.*/``
   :type nodes: nodeSpec

   Return table columns:

   #. **Node**

   #. **Filter_Name** -- Filter name.

.. py:class:: resolveInterfaceSpecifier(*, interfaces, grammarVersion, nodes, question_name)

   Returns the set of interfaces corresponding to an interfaceSpec value.
   
   Helper question that shows how specified interfaceSpec values resolve to the interfaces in the network.
   
   
   :param interfaces: *Required.* Input to the interfaceSpecifier.
   :type interfaces: interfacesSpec
   :param grammarVersion: Version of grammar to use for resolution.
   :type grammarVersion: string
   :param nodes: Input to the NodeSpecifier that specifies the set of nodes that should be considered.
   
       Default value: ``/.*/``
   :type nodes: nodeSpec

   Return table columns:

   #. **Interface**

.. py:class:: resolveIpSpecifier(*, ips, grammarVersion, question_name)

   Returns the IP address space corresponding to an ipSpec value.
   
   Helper question that shows how specified ipSpec values resolve to IPs.
   
   
   :param ips: *Required.* Input to the IP space specifier.
   :type ips: ipSpaceSpec
   :param grammarVersion: Version of grammar to use for resolution.
   :type grammarVersion: string

   Return table columns:

   #. **IP_Space** -- IP space.

.. py:class:: resolveIpsOfLocationSpecifier(*, locations, grammarVersion, question_name)

   Returns IPs that are auto-assigned to locations.
   
   Helper question that shows IPs that will be assigned to specified locationSpec values by questions are automatically pick IPs based on locations.
   
   
   :param locations: *Required.* Input to the LocationSpecifier.
   :type locations: locationSpec
   :param grammarVersion: Version of grammar to use for resolution.
   :type grammarVersion: string

   Return table columns:

   #. **Locations** -- Resolution.

   #. **IP_Space** -- IP space.

.. py:class:: resolveLocationSpecifier(*, locations, grammarVersion, question_name)

   Returns the set of locations corresponding to a locationSpec value.
   
   Helper question that shows how specified locationSpec values resolve to the locations in the network.
   
   
   :param locations: *Required.* Input to the LocationSpecifier.
   :type locations: locationSpec
   :param grammarVersion: Version of grammar to use for resolution.
   :type grammarVersion: string

   Return table columns:

   #. **Location**

.. py:class:: resolveNodeSpecifier(*, nodes, grammarVersion, question_name)

   Returns the set of nodes corresponding to a nodeSpec value.
   
   Helper question that shows how specified nodeSpec values resolve to the nodes in the network.
   
   
   :param nodes: *Required.* Input to the NodeSpecifier.
   :type nodes: nodeSpec
   :param grammarVersion: Version of grammar to use for resolution.
   :type grammarVersion: string

   Return table columns:

   #. **Node**

.. _initialization:

Initialization information questions
------------------------------------

Question that reveal how well Batfish understood input data.

.. py:class:: fileParseStatus(*, question_name)

   Displays file parse status.
   
   For each file in a snapshot, returns the host(s) that were produced by the file and the parse status: pass, fail, partially parsed.

   Return table columns:

   #. **File_Name** -- The file that was parsed.

   #. **Status** -- The status of the parsing operation.

   #. **Nodes** -- Names of nodes produced from this file.

.. py:class:: initIssues(*, question_name)

   Returns issues encountered when processing the snapshot.
   
   Reports issues encountered by Batfish, including failure to recognize certain lines in the configuration, lack of support for certain features, and errors when converting to vendor-independent models.

   Return table columns:

   #. **Nodes** -- The nodes that were converted (if applicable).

   #. **Source_Lines** -- The files and lines that caused the issues (if applicable).

   #. **Type** -- The type of issues identified.

   #. **Details** -- Details about the issues identified.

   #. **Line_Text** -- The text of the input files that caused the issues (if applicable).

   #. **Parser_Context** -- Batfish parser state when issues were encountered (if applicable).

.. py:class:: parseWarning(*, aggregateDuplicates, question_name)

   Returns warnings that occurred when parsing the snapshot.
   
   Return warnings such as failure to recognize certain lines and lack of support for certain features.
   
   
   :param aggregateDuplicates: Whether to aggregate duplicate results.
   :type aggregateDuplicates: boolean

   Return table columns:

   #. **Filename** -- The file that was parsed.

   #. **Text** -- The text of the input that caused the warning.

   #. **Line** -- The line number in the input file that caused the warning.

   #. **Parser_Context** -- The context of the Batfish parser when the warning occurred.

   #. **Comment** -- An optional comment explaining more information about the warning.

.. py:class:: viConversionStatus(*, question_name)

   Displays vendor independent conversion status.
   
   For each node in a snapshot, returns the vendor independent conversion status: pass, fail, converted with warnings.

   Return table columns:

   #. **Node** -- The node that was converted.

   #. **Status** -- The status of the conversion operation.

.. py:class:: viConversionWarning(*, question_name)

   Returns Batfish warnings that occurred when converting to vendor independent model.
   
   When converting configurations to a vendor independent model Batfish may generate warnings for unsupported features and for unexpected configurations (e.g., missing definitions). This question lists those warnings.

   Return table columns:

   #. **Node** -- The node that caused the warning.

   #. **Type** -- The type of the warning.

   #. **Comment** -- The description of the warning.

.. _other:

Other questions
---------------

Questions that do not belong to any other category

.. py:class:: filterTable(*, innerQuestion, columns, filter, question_name)

   Returns subset of answer for a question.
   
   Return a subset of the answer generated by the inner question. The results are trimmed first by row and then by column. Rows where any value matches the filter are returned. The columns returned for each row is restricted by the column specifier.
   
   
   :param innerQuestion: *Required.* The inner question whose answer should be filtered.
   :type innerQuestion: question
   :param columns: The set of columns to fetch.
   :type columns: string
   :param filter: The filter to use.
   :type filter: string

